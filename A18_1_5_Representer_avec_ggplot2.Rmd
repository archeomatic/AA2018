---
title: "AA18.1: Découverte du tidyverse"
output:
  html_document:
    df_print: paged
---
# Manipulation de données avec `dplyr` et `tidyr`

```{r echo = FALSE}
# définir le répertoire de travail
setwd("~/SLY_Perso/COLLOQUES/AArcheomatiques/AA181_aRcheologie/AA18_1_Presentation/Data")

# installer les packages du tidyverse (ne faire qu'une fois puis commenter la ligne en ajoutant un #)
# install.packages("tidyverse")
# activer le packages
library(tidyverse)
library(readxl)
```

# importer le fichier excel

```{r message=FALSE, warning=FALSE}
cer <- read_xls("Amboise_ceram.xls")
```

3 façon de regarder/ d'explorer la table importée

```{r message=FALSE, warning=FALSE}
View(cer) # pour visualiser le data.frame sous forme de tabbleau
str(cer) # pour regarder la structure
summary(cer) # pour faire un résumé statistique
```

# NETTOYAGE

## LES COLONNES (selection, renommage)

# plusieurs colonnes ne m'intéressent pas: la 3 (Sd), la 4 (Carré), la 9 (Variante) que des NA, la 13 (DATATION (éléments)), et la 16 (X_1) (colonne vide)
# Je veux donc éliminer ces colonnes
cer <- dplyr::select(cer, 1:15, -3, -4, -9, -13)
# NOTE: le préfixe dplyr:: permet d'imposer le package utilisé en cas de nomd de fonction en conflit entre plusieurs package.
# Il n'est pas nécessaire ici mais permet de savoir dans quel package se trouve la fonction. 
# NOTE2: je stocke le résultat dans l'objet cer pour le garder
# Je peux vérifier le résultat en refaisant un str()
str(cer)

# Je peux aussi tout simplement regarder seulement le nom des colonnes avec la fonction names()
names(cer)
# Cette même fonction peut permettre de modifier les noms de colonnes ainsi
# il est recommandé d'avoir des noms de variables simples, court, explicite et en minuscule
names(cer) <- c("lot","fait", "us", "group_tech", "production", "forme", "fonction", "nr", "nmi", "datation", "horizon")
# il existe aussi une fonction equivalente dans le package dplyr:: 
cer <- dplyr::rename(cer, chrono = datation)

# l'objet de ce script est de préparer ce tableau pour faire une analyse statistique.
# il peut être utile pour certaines variables qualitatives de regarder les modalités (leur nombre et la façon dont elles ont été enregistrée)
# par exemple regarder toutes les modalités (toutes les valeurs uniques) de la variable groupe_tech
unique(cer$group_tech)
# => Il ya 147 modalités nous ne pouvons rien en faire nous allons donc élimier cette colonne
cer <- dplyr::select(cer, -group_tech)
# NOTE: nous avons utilisé directement le nom de la colonne (au lieu de son rang comme précedemment)

# EXERCICE: identifier les différentes modalités de la variable horizon
unique(cer$horizon)
# => Je remarque que certains enregistrements de l'appartenance à un horizon sont flous (plusieurs horizons ex: 1_2_3 )!

## LES LIGNES / ENREGISTREMENTS (filtre, tri, recodage)

# je décide de les éliminer (mais aussi les horizons > 4, c'est la céramo qui me l'a dit!)
# avec la fonction filter(x, condition)
cer <- dplyr::filter(cer, horizon %in% c(1,2,3,4))
# ou 
cer <- dplyr::filter(cer, horizon %in% 1:4)
# NOTE: on peut utiliser les opérateurs logiques & (AND), | (OR) ! (NOT), %in% (IN)

# On peut maintenant trier le tableau selon la variable horizon avec la fonc tion arrange(x, variable)
cer <- dplyr::arrange(cer, horizon)

# Il faut aussi savoir que l'on peut extraire des données selon les numéros de lignes avec la fonction slice(x, numéros de ligne)
# pour extraire les 10 premières lignes
dplyr::slice(cer, 1:10)
# Mais cela n'a pas d'utilité ici !

# On peut vouloir ajouter une colonne issue d'un calcul par exemple la fréquence relative de chaque nr par rapport à la totalité
cer <- dplyr::mutate(cer, freq_nr = nr/sum(nr)*100)

# On va s'intéresser à la variable production qui indique les provenances des lots de céramiques
unique(cer$production)
# ou encore si l'on veut voir le décompte par modalités
table(cer$production)
# => C'est le bordel non ? (Majuscule/minuscule, incertitudes... Il va falloir recoder tout cela !
# Cela tombe bien il existe un package du Tidyverse déié à cela : FORCATS
# Mais il ya mieux: un package offrant une interface pour le faire !
# on installe le package de sociopathes
# install.packages("questionr")
# On l'active
library(questionr)
# On utilise la fonction pour recoder une variable qualitative irec(variable)
# Pour ne garder que locale, gauloise, mediteraneenne, indeterminee
# irec(cer$production)

## Recodage de cer$production en cer$production_rec
cer$production_rec <- fct_recode(cer$production,
               "locale" = "Production locale",
               "méditerranéenne" = "Importation méditerranéenne",
               "gauloise" = "Importation gauloise",
               "indéterminée" = "Indéterminée",
               "indéterminée" = "ind",
               "gauloise" = "importation gauloise",
               "indéterminée" = "Production locale?",
               "indéterminée" = "importation gauloise?",
               "indéterminée" = "Importation gauloise?",
               "locale" = "Production Locale",
               "indéterminée" = "Importation Lyon",
               "indéterminée" = "Importation gauloise/Production locale",
               "indéterminée" = "Production Locale?",
               "indéterminée" = "Production Locale ?",
               "locale" = "Production régionale",
               "indéterminée" = "Production lyonnaise?",
               "indéterminée" = "La Graufesenque")
cer$production_rec <- fct_explicit_na(cer$production_rec, "indéterminée")
View(cer)

# => On est content de la forme que nous avons donné au tableau on peu donc l'enregistrer au format csv
write_csv(cer, "Ceram_amboise.csv")

test <- fct_collapse(cer$production,
                     "gauloise" = c("importation gauloise"))

# ON refait un table()
table(cer$production_rec)
# => Peut-être cela semble compliqué Mais il y a un énorme avantage on ne touche pas au tableau de départ et cette opération est donc transparente, reproductible et modifiable.

## Enchainer les opérations avec le pipe (%>%)

# Nous savons faire plein de choses avec R et ses fonctions en enchainant les commandes lignes après lignes et en "écrasant" un objet...
# Ou en emboitant les fonctions...

# EXEMPLE: on veux faire un diagramme en barre de la quantité de céramique (nr) par lieu de production par ordre décroissant:

# SOlution 1 on emboîte les fonctions
barplot(sort(tapply(cer$nr, cer$production_rec, sum), decreasing = TRUE))
# => Ca fonctionne mais:
# 1) C'est dur à lire
# 2) Les opérations apparaissent dans le sens inverse de leur execution
# 3) Il est difficile de voir quel paramètre appartient à quelle fonction

# Solution 2: on effectue les opérations les unes après les autres, en stockant le résultat intermédiaire dans un ojet temporaire
toto <- tapply(cer$nr, cer$production_rec, sum)
toto
toto <- sort(toto, decreasing = TRUE)
toto
barplot(toto)
# => C'est plus lisible et on voit bien les arguments Mais
# 1) C'est un peu "verbeux"
# 2) l'objet toto ne sert à rien..

# Il existe un moyen de rendre le code plus lisible le pipe (Ctrl + shift + M) 
# cela crée un tube, un pipeline qui permet de mettre le résultat de la fonction à gauche du pipe comme argument principal de la fonction à droite du pipe
# Par exemple:
filter(cer, production_rec == "gauloise")
# est équivalent à
cer %>% filter(production == "gauloise")

# avec notre exemple on peut donc faire
tapply(cer$nr, cer$production_rec, sum) %>% sort(decreasing=TRUE) %>% barplot

# EXERCICE NUL: stocker dans un objet cool un tableau contenant uniquement les colonnes forme et chrono pour les lots de céramiques de l'horizon 3, triés selon le NR
cool <- cer %>% 
  arrange(nr) %>%
  filter(horizon == "3") %>% 
  select(fonction, chrono)
# NOTE: quand on organise sont code sur plusieurs lignes le %>% doit être en bout de ligne.

# On passe donc d'une écriture verbe(sujet, complements) à sujet %>% verbe(complement)

## OPERATIONS GROUPEES

# On peut définir des groupes de lignes à partir d'une ou plusieurs colonnes.
# par exemple les lots de céramique selon leur horizon d'appartenance
cer %>% dplyr::group_by(horizon)
# => Rien ne semble s'être passé si ce n'est l'indication Groups: horizon [4]
# Mais à partir du moment où des groupes ont été définis, les verbes comme slice, mutate ou summarise vont en tenir compte lors de leurs opérations.

# Ainsi sion applique le verbe slice() après avoir groupé par horizon...
cer %>% group_by(horizon) %>% slice(1)
# il nous renvoie les 1ères lignes (dans l'ordre de saisie) pour chaque horizon

# de la même façon si on crée une colonne avec la fonction mutate il le fera en fonction des groupes
cer %>% group_by(horizon) %>% mutate(freq_nr_horizon = nr/sum(nr)*100)
# on le comprends peut être mieux quand on demande de créer une colonne content la somme de nr pour chaque groupe
cer %>% group_by(horizon) %>% mutate(sum_group = sum(nr))
# => Cette colonne est bien entendue inutile mais utile pour la démonstration !

# En effet si l'on désire connaitre la somme des nr (ou tout autre calcul) par groupe il existe une fonction de résumé dédiée summarise(nouvelle_variable = sum(variable))
cer %>% group_by(horizon) %>% summarise(sum = sum(nr))

# EXERCICE: calculer la moyenne des nmi par fait
cer %>% group_by(fait) %>% summarise(sum_nr=sum(nr), sum_nmi=sum(nmi))

# Il existe aussi un opérateur spécial pour la fonction summarise pour compter les enregistrements: n()
# Ainsi pour compter le nombre de lots par faits 
cer %>% group_by(fait) %>% summarise(nb = n())

# On peut aussi regrouper sur plusieurs variables
# Si l'on veut compter le nombre de lot par fait et par us
cer %>% group_by(fait, us) %>% summarise(nb = n()) %>% arrange(nb)

# Mais revenons à nos moutons...euh à nos céram
# Mon but est de préparer la journée de demain en créant un tableau contenat
# de la chrono en ligne: mes horizons conviendront parfaitement
# de la quantification en colonnes: je voudrais pour chaque origine de production, la somme des nr

# s'il fallait faire un simple tableau de contingence des 2 variables, on sait faire ?
tab <- table(cer$horizon, cer$production_rec)
# => Mais je veux la somme des nr !

# avec les fonctions group_by et summarise je sais créer la somme des nr pour chaque couple horizon / production_rec
tab2 <- cer %>% group_by(horizon, production_rec) %>% summarise(sum_nr = sum(nr))
tab2
# => Ok ca marche mais par contre il ne ressemble pas a un tableau croisé comme on en a l'habitude ?!

# encore une fois cela tombe bien car il existe un package du tidyverse dédié aux manipulation de rangement des données c'est le package tidyr
# tidy ca veut dire "rangé" (le contraire c'est "messy")
# Il n'y a que 3 règles de bases (qui paraissent simples mais...)
# 1) chaque ligne correspond à une observation
# 2) chaque colonne correspond à une variable (ou un cas).. c'est la que c'est pas simple
# 3) chaque valeur doit être présente dans une seule case (sinon il faut une autre table) par ex. les colonnes chrono et horizon sont redondantes, il faudrait -pour être tidy- n'en garder qu'une seule et créer une table avec les colonnes horizon et chrono

# Pour passer d'un tableau long à un tableau large on utilise la fonction spread() "étendre" comme dans man spreading ;)
# la fonction spread prend comme arguments (key=colonne a mettre en largeur, value=colonne contenant les valeurs)
tab3 <- tab2 %>% spread(key=production_rec,value=sum_nr)
tab3
# On peut enregistrer le résultat de nos efforts dans un tableau a exploiter demain avec la fonction write_csv()
write_csv(tab3, "Tab_croise_AMboise.csv")
# NOTE: le logiciel enregistre le tableau dans le répertoire de travail

# Pour faire l'inverse, passer d'un tableau en largeur à un tableau en longueur on utilise gather ("rassembler") 
# les arguments sont
# 1) les noms colonnes à rassembler ou -celle a ne pas prendre en compte
# 2) key = le nom de la colonne créée récupérant les coms de colonnes en modalités
# 3) value = nom de la colonne créée récupérant les valeurs
tab3 %>% gather(-horizon, key = origine, value = sum_nr)

# On peut aussi séparer une colonne en plusieurs colonnes avec la fonction separate(colonne a traiter, c("col1","col2"), sep = "")
# On aurait pu tenter pour nettoyer la colonne production:
test <- cer %>% separate(production, c("prefixe", "origine"))
# NOTE: remarquer que si l'on ne définit pas de séparateur la fonction coupe aux caracteres non alphanumérique (espace, tiret, slash..)
View(test)

# L'inverse c'est à dire l'équivalent de la concaténation c'est la fonction unite()
# Si on veut faire une colonne d'identifiant basée sur la concatenation des colonnes lot, fait et us
cer %>%  unite(ID, lot, fait, us)
# NOTE: par défaut il ajoute un _ entre les termes concaténés et supprime les colonnes d'origine !
# on peut éviter cela avec les arguments sep = et remove = FALSE
cer %>%  unite(ID, lot, fait, us, sep = " ", remove = FALSE)

# VISUALISER/REPRESENTER LES DONNEES

# ggplot2

## DIVERS
cer$horizon <- as.character(cer$horizon)
cer$production_rec <- as.character(cer$production_rec)
zob <- cer %>% group_by(horizon, production_rec) %>% summarise(sum_nr = sum(nr)) 
zob

ggplot(zob, aes(horizon,sum_nr))+
  geom_line(aes(group=production_rec, colour=production_rec))


ggplot(zob, aes(horizon,sum_nr))+
  geom_line(aes(group=production_rec), colour="grey50")+
  geom_point(aes(colour=production_rec))

# Le Nettoyage du tableau en un minimum de lignes
library(tidyverse)
library(readxl)
cer <- read_excel("Amboise_ceram.xls")
str(cer)
cer <- cer %>% select(1:15, -3, -4, -9, -13, -groupe_tech) %>%
  rename(lot = NUM_LOT,
         fait = Fait,
         us = US,
         production = Production,
         fonction = Fonction,
         nr = NR,
         nmi = NMI,
         chrono = "DATATION (ensembles)",
         horizon = HORIZON) %>% 
  filter(horizon %in% 1:4) %>% 
  arrange(horizon)
## Recodage de cer$production en cer$production_rec
cer$production_rec <- fct_recode(cer$production,
                                 "locale" = "Production locale",
                                 "méditerranéenne" = "Importation méditerranéenne",
                                 "gauloise" = "Importation gauloise",
                                 "indéterminée" = "Indéterminée",
                                 "indéterminée" = "ind",
                                 "gauloise" = "importation gauloise",
                                 "indéterminée" = "Production locale?",
                                 "indéterminée" = "importation gauloise?",
                                 "indéterminée" = "Importation gauloise?",
                                 "locale" = "Production Locale",
                                 "indéterminée" = "Importation Lyon",
                                 "indéterminée" = "Importation gauloise/Production locale",
                                 "indéterminée" = "Production Locale?",
                                 "indéterminée" = "Production Locale ?",
                                 "locale" = "Production régionale",
                                 "indéterminée" = "Production lyonnaise?",
                                 "indéterminée" = "La Graufesenque")
cer$production_rec <- fct_explicit_na(cer$production_rec, "indéterminée")

